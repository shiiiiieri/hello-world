---
layout: page
title: "software Eng. lecture note
parmalink: /docs/softwareEng2025
---

## ソフトウェア工学とは
ソフトウェア工学は「品質」、「コスト」、「納期」の最適なバランスを実現するための手法・方法論のことである。ソフトウェア工学は以下の４つの理由から必要な工学である。　　
>1. 大規模化と複雑さ  
>2. IT人材の不足  
>3. 社会性と求められるミッション  
>4. 不確実性の増大  

Hyrumの法則により、ユーザはソフトウェアを自由に使うことができる。  

### ソフトウェアとは
ソフトウェアは「情報」を扱うプロダクトそのものの事であり、プロダクトを提供する手段である。ソフトウェアは以下の3項目によって定義され、劣化はしない一方、悪化するというデメリットがある。  

**ソフトウェアの定義**
>1. 実行される事によって必要な特性、機能、性能を提供する命令語群（コンピュータプログラム）  
>2. プログラムが適切に情報を扱うことを可能とするデータ構造   
>3. プログラムの操作や使用法を記述した情報 

また、ソフトウェアには以下の4つの特徴がある。
>1. 新しい環境や技術のニーズを満たすよう適応しなければならない   
>2. 新しいビジネス要求を実現するために強化されなければならない  
>3. より近代的なシステムやデータベースと相互運用するため拡張されなければならない   
>4. 進化し続ける環境で実行可能となるよう、再構築されなければならない  

これらの定義と目標からソフトウェア工学では、ソフトウェアシステムが変化し続ける状況に対応する進化論に基づく方法論を考え出すことがゴールとされている。　　

## ソフトウェアライフサイクル
ソフトウェアは以下の手順で誕生し開発、運用、廃止へと進む。またこれらの3要素のサイクルがソフトウェアライフサイクルである。  
 - **ソフトウェア誕生手順**　　
>1.ニーズの発生  
 2.ビジネスやシステム上の要求を具現化するための企画や計画の実行  
 3.要件定義書をまとめる　　

 - **ソフトウェアの開発、運用手順**
>1.ソフトウェアの開発\
 2.実稼働\
 3.保守運用  

- **ソフトウェアの廃止**
>1.サービスの終了\
 2.新規ソフトウェアへのリニューアル  

### 要件定義
要件定義では実現する機能・実現しない機能を明確にすることを目的としており、機能の絞り込み、スケジュールの見直し、代替策の検討などに繋がる大切な事項である。具体的には以下のような物が定義される。　　

>- システムの目的
>- システムの概要
>- システムの機能
>- システム達成
>- 目標性能
>- 他のシステムとのインターフェース仕様
>- 運用面での注意事項
>- 制限事項
>- 拡張性
>- 開発スケジュール
>- 開発体制
>- 納品物　　

要件定義の意義には、<ins>プロジェクト関係者のバイブルとなること</ins>、<ins>社内外への宣言と協力依頼をすること</ins>、<ins>Request for Proposal</ins>がある。要件定義で行われることには、**設計**、設計書に従い内製か調達かを決めシステム構築を行う**製作**、賃金の安い海外企業に外部委託する手法である**オフショア開発**、**テストとデバック**、**運用・保守**、**ドキュメンテーション**がある。　　
## プロジェクトとは
プロジェクトとは、終わりがある仕事である**有期性**と独自の目的を達成する仕事の**独自性**を兼ね備えた**バックキャスティング**である。バックキャスティングとは、何を成し遂げたかのアウトプット視点であり、目標に向けて必要な物を計画し達成に向かうものだ。そのため、目標を明確にし、適宜修正可能である事の多い目標に向けての筋道を、その都度検討する必要がある。対義語である**フォアキャスティング**は、どれほどやったかのインプット視点であり、現時点から順に目標に向けて進んでいくものだ。これは目標に到達できない可能性がある。

## ソフトウェア分析について　　
ソフトウェアを見える化するための方法には以下の物がある  
>- **ソフトウェアの物量に関する分析**  
ある言語に換算した際のソースコード行数（総ステップ数）と組み込みソフトウェアのサイズ（オブジェクト容量）   
>- **ソフトウェアの実効性能に関する分析**  
プログラミングフェーズに入る前にユーザー要件が定まり、必要な機能が見えてきた段階でシステム規模を概算することができるファンクションポイント法がある。これは**大まかな見積もり→仕様の設計→再見積もり→システム規模の見積もり**の順で行われ、投資意思決定にも利用できる。また、使い勝手も**画面の視認性、操作性、入力補助、互換性、ガイダンス**の観点から分析され、評価される。  
>- **ソフトウェアの開発工数に関する分析**  
「Hyrumの法則」を想定し、リリースなどについて検討する。  
>- **ソフトウェアの品質に関する分析**  
「Hyrumの法則」を想定し、バグについて検討する。
バグ発生率は１ステップ数（改行を除いたコード行数）あたりの発生バグ数を求めることで計算できる。

これらはQCDに使用される

### QCDとは
QCDは品質（Quality）、コスト（Cost）、納期（Delivery）の事であり、それぞれの要素を重視したシステムには以下のようなものがある。　　
>- 品質優先･･･人名に影響があるシステム
>- 費用優先･･･公共関連システム
>- 納期優先･･･イベント行事関連システム
## 開発プロセス  
開発プロセスには以下のようなものがある。  

- **ウォーターフォール型開発プロセス**  
進捗管理が容易で成果物が明確だが後工程にしわ寄せがくる可能性がある。  

- **反復型開発プロセス**  
ソフトウェアを機能分割し、これを「反復」と呼ぶ単位で管理する積み上げ方式の開発プロセスで、顧客の要求を取り入れやすい、部分的な納品が可能であるが、作業や管理業務が増える、全体像が把握しにくいなどのデメリットがある。  

- **スパイラルモデル**  
**プロトタイプ→提案→評価→フィードバック**のサイクルであり、
プログラムを小さなフェーズに分割し、フェーズごとにフィードバックする。プロトタイプ作成の際に想定外の作業量が発生するリスクがある  

- **アジャイルプロセス**  
ウォーターフォール型開発プロセスでは想定されていなかった「できるだけ決定を遅らせる」、「できるだけ早く提供する」を実現した開発方法で、変化に対応して無駄を廃し、最適な手法で動くソフトウェアの提供を優先する。アジャイル開発には12個の原則があり、その原則に則り開発が進められている。この開発方法は以下の点で価値が見いだされている。  
>- プロセスやツールよりも、個人や個人や相互作用である点  
>- わかりやすいドキュメントよりも、動くソフトウェアである点
>- 契約上の駆け引きよりも、顧客とのコラボレーションである点
>- 計画を硬直的に守るよりも、変化への対応できる点  

これらの方法から、様々な観点を検討した上で、状況に応じて1つの方法やハイブリッド型の方法が用いられている。

## WBS  
WBSとはプロジェクト目標を達成し、必要な要素成果物を生成するために、プロジェクトチームが実行する作業を、要素成果物を主体に階層的に要素分解したものであり、以下の手順で行う。  
>1. トップダウンアプローチかつバックキャスティングでスコープを明確にする  
>2. 大きな作業をグルーピングする  
>3. データ収集をしたあと分析することでグループングした作業の相互関連を考える  
>4. 各グループの作業をもれやダブりがないよう洗い出す

WBSのメリットには以下のようなものがある。  
>- スコープを明確にする事でやらないことが明確になる
>- やるべき作業も明確になる
>- 全体管理と作業計画が明確になる
>- プロジェクト実施時に何をすれば良いかが分かりやすい
 
## コーディング  
コードは読まれることの方が多いため、ソフトウェア開発にあたり読みやすいコードを書くことは必須である。そのため様座なルールがあるが、その1つにPythonのPEP8がある。  

>**1行の長さ**  
>- 基本79字以内、docstring やコメントは72文字以内
>- 行を継続する場合は、折り返された要素を縦に揃える  

>**レイアウト**
>- 1レベルインデントするごとに、スペースを4つ使う
>- 演算子の前後にスペースを1つずつ空ける
>- 無駄なスペースは入れない

>**改行**
>- 文を重ねない
>- 演算子の位置を揃える  

>**import**
>- 標準ライブラリ
>- サードパーティに関連するもの
>- ローカルな アプリケーション/ライブラリ に特有のもの

>**コメント**
>- コードを変更したときはコメントも最新にする（矛盾したコメントがないようにする）
>- はじめの単語は、小文字で始まる識別子でない限り大文字から始める（識別子の大文字、小文字は絶対に変更しない）
>- ブロックコメントは一般的に1つ以上の段落からなり、文は完全な文でピリオドで終わる。
>- 2つ以上のコメントの場合、文の終わりには2つスペースを入れる（最後の文は除く）
>- コメントは英語を使い、どんな話者が読んでも明快かつ分かりやすくする。

>**命令規則**  
>- パッケージ  
全て小文字の短い名前、アンダースコアは使わない
>- モジュール  
全て小文字の短い名前、アンダースコアで区切ってもよい
>- クラス、例外  
CapWords方式 （先頭だけ大文字の単語を繋げる、アンダースコアは使わない）
>- 関数、メソッド
小文字のみ、必要に応じて単語をアンダースコアで区切る
>- 定数  
大文字のみ、単語をアンダースコアで区切り、普通モジュールレベル（関数の外）に書く
>- 変数、引数  
小文字のみ、必要に応じて単語をアンダースコアで区切る
>- 1文字変数  
l (エル)、O (オー)、I(アイ) は使わない  

>**その他**
>- UTF-8以外のエンコーディングは基本使わない
>- ASCII文字以外の使用を極力避ける
>- プロジェクトの中で一貫性を保つことを第一に考える  

これらの規則のチェックツールとして、flake8やpylintがある。

## バージョン管理
バージョン管理とは、ファイルを「誰が」、「いつ」、「どのように」変更したかを管理するもので、これらが管理されていることで複数メンバーと共同でコード開発ができるようになる。2つの型がある。

### 集中管理型
リモートリポジトリのみがバージョン管理される。同時編集をするとコンフリクトが発生しやすく、同期に時間がかかる。

### 分散管理型  
ローカルでもバージョン管理される。リモートリポジトリへのアクセス頻度が低く、障害に頑健である。

## git  
分散管理型のバージョン管理システムで、元々はオープンソースソフトウェア管理のためのソフトウェアであった。  
変更履歴が残る点、変更した箇所に戻ることができる点、他人と共同編集できる点で優れている。機能には以下のようなものがある。  

- **コミット**  
ファイル作成、変更、削除の記録を行う。対象ファイルの数に制限はなく、コミットの単位はユーザーが自由に決定する。  

- **レポジトリ**  
gitが管理するプロジェクトのフォルダであり、個々のプロジェクト実行環境であるローカルレポジトリと、共有の管理場所であるリモートリポジトリがある。流れは以下の通りである。  

>**ローカルレポジトリ**  
>1. ワークツリー  
gitで管理されていないファイルの状態（untracked）とgitで管理されているが変更されていないファイルの状態（unmodified）、gitで管理されていて変更されたファイルの状態（modified）があり、変更し保存することで状態を変える。  
>2. ステージングエリア、インデックス  
ワークツリーの処理の後、コミットしたいファイルをgit addで登録する。  
>3. Gitディレクト  
commitにより変更を登録する。commitは原則、変更・削除できず、commitの変更・削除も記録として残る。commitされたファイルはunmodifiedの状態になる。  
>4. ローカルレポジトリでcommitされた変更をgit pushでリモートレポジトリへ反映する。  
>5. リモートレポジトリにある内容をgit pullでローカルレポジトリに反映する。  

以下のようなものもある。

>- ブランチ  
作業を枝分かれさせることができ、共同作業や並行作業が可能になる。  
>- gitignore  
gitに管理してほしくないファイルを指定する  

gitには様々なコマンドがある。

>**設定、確認系**  
>- git init  
gitの初期化と設定開始を行う
>- git status  
ワークツリーのステータスを表示する
>- git config  
設定周りの確認と変更を行う
>- git log  
ログを表示する。--　onelineでコミットメッセージの1行のみの一覧表示する。
>- git diff  
ファイルの差分を表示する  

>**コミット系**
>- git add  
ステージングエリアに追加する
>- git commit  
コミットの実行を行う

>**修正系**  
>- git commit --amend  
コミットの修正を行う
>- git checkout  
変更がstaging area/index内にある場合、削除されたファイルを復旧や過去コミットの復元などを行う  
>- git reset  
コミットのリセットを行う
>- git revert  
コミットの変更を打ち消すコミット
>- git rm  
ファイルとindex情報の削除を行う  

>**リモート系**  
>- git clone  
レポジトリをコピーする
>- git pull  
リモートレポジトリの同期を行う
>- git push  
変更をアップロードする
>- git request-pull  
変更依頼であるプルリクエストを行う
>- git remote  
リモートレポジトリの設定を行う

>**ブランチ系**
>- git branch  
ブランチの作成を行う
>- git checkout  
ブランチの切り替えを行う
>- git merge  
ブランチの統合を行う
>- git clone  
レポジトリをコピーする
>- git push  
変更をアップロードする

## Github  
リモートレポジトリのホスティングサービスの1
つであり、オープンソースソフトウェアの主要なポータルサイトである。以下のようなソフトウェア・エンジニアリングがある。  

>- clone  
自分のリモートレポジトリの内容をローカルレポジトリにコピーする
>- fork  
他のユーザーのリモートリポジトリを自分のリモートリポジトリにコピーする。  
>- template  
いくつでもforkできる  
>- issues  
レポジトリに関する問題、課題、バグ、機能追加や質問などを挙げるための機能である
>- projects  
issuesなどを管理するためのテーブル  

また、簡単に文章を記述する記法として、マークダウンがある。

## CI/CD  

### CI  
Continuous Integrationのことである。コード変更を共有リポジトリに頻繁に統合するプロセスで、自動テストとビルドを定期的に実行し、バグの早期発見と修正を可能にする。CIの自動化により開発のスムーズな進行を促進する。  

### CD  
Continuous Deliveryのことである。コード変更をテスト環境や本番環境に自動的にデプロイするプロセスで、自動デプロイメントを組み込み、手動操作によるデプロイの必要性を排除する。CDにより、ユーザーフィードバックを迅速に反映可能にする。  

CI/CDパイプラインの基本的なステップは以下の通りである。  

>- ソース  
コード変更をトリガーにワークフローを起動する
>- ビルド  
ソースコードをコンパイルする  
>- テスト  
自動テストを実行する  
>- デプロイ  
テスト済みのコードを本番環境にデプロイする
>- 検証  
デプロイされたアプリケーションの動作確認する  
>- モニタリング  
本番環境での継続的な監視する  

GitHub Actionsを使用した場合、以下の流れになる。

>- ワークフローの定義  
YAMLファイルで定義され、 .github/workflows/ディレクトリに配置される。イベント、ジョブ、ステップで構成される。
>- トリガー  
プッシュ、プルリクエスト、スケジュールなど様々なイベントでワークフローを起動可能にする  
>- ジョブとステップ  
ジョブでは並列実行が可能である。ステップでは、シェルコマンドの実行やアクションの使用が可能である。
>- アクション  
再利用可能なワークフローの構成要素であり、コミュニティが作成したアクションも利用可能である  
>- ランナー  
ホステッドランナーまたはセルフホステッドランナーを使用可能である  

また、CI/CDによりホームページを自動で更新することもできる。





